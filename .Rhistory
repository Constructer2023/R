kable(data, caption = "Student grade data") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "bordered"),
full_width = FALSE) %>%
column_spec(1, width = "10cm", latex_column_spec = "c") %>%
column_spec(2 : 4, width = "5cm", latex_column_spec = "c")
library(knitr)
library(kableExtra)
library(magrittr)
data <- data.frame(
functions = c("abs(x)", "sqrt(x)", "ceiling(x)", "floor(x)", "trunc(x)", "round(x, digits = n", "signif(x, digits = n)", "cos(x), sin(x), tan(x)", "acos(x), asin(x), atan(x)", "cosh(x), sinh(x), tanh(x)", "acosh(x), asinh(x), atanh(x)", "log(x, base = n)", "log(x)", "log10(x)", "exp(x)"),
description = c("Absolute value, abs(-4) returns 4",
"Square root, sqrt(25) returns 5",
"The smallest integer not less than x, ceiling(3.475) returns 4",
"The largest integer not greater than than x, floor(3.475) returns 3",
"Truncate the integer part towards the direction of 0, trunc(5.99) returns 5",
"Round x to a decimal of the specified place, round(3.475, digits = 2) returns 3.48",
"Rounds x to the specified number of significant digits, signif(3.475, digits = 2) returns 3.5",
"Cosine, sine, and tangent, cos(2) returns -0.416",
"Arccosine, arcsine, and arctangent, acos(-0.416) returns 2",
"Hyperbolic cosine, hyperbolic sine, hyperbolic tangent, sinh(2) returns 3.627",
"Inverse hyperbolic cosine, inverse hyperbolic sine, inverse hyperbolic tangent, asinh(3.627) returns 2",
"Take the base n logarithm of x",
"Natural logarithm of x, log(10) returns 2.3026",
"Common logarithm of x, log10(10) returns 1",
"Exponential function, exp(2.3026) returns 10")
)
kable(data, caption = "Mathematical functions") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "bordered"),
full_width = FALSE) %>%
column_spec(1 : 2, width = "10cm", latex_column_spec = "c")
library(knitr)
library(kableExtra)
library(magrittr)
data <- data.frame(
functions = c("mean(x)", "median(x)", "sd(x)", "var(x)", "mad(x)", "quantile(x, probs)", "range(x)", "sum(x)", "diff(x, lag = n)", "min(x)", "max(x)", "scale(x, center = TRUE, scale = TRUE)"),
description = c("Mean. e.g., mean(c(1, 2, 3, 4)) returns 2.5",
"Median. e.g., median(c(1, 2, 3, 4)) returns 2.5",
"Standard Deviation. e.g., sd(c(1, 2, 3, 4)) returns 1.29",
"Variance. e.g., var(c(1, 2, 3, 4)) returns 1.67",
"Median absolute deviation. e.g., mad(c(1, 2, 3, 4)) returns 1.48",
"Quantile. The x is a numeric vector waiting for quantile, probs is a numeric vector formed by a probability between 0 and 1. e.g., # Calculate the 30% and 84% quantile of x, y <- quantile(x, c(.3, .84))",
"Calculate Range. e.g., x <- c(1, 2, 3, 4), range(x) returns c(1, 4)",
"Sum. e.g., sum(c(1, 2, 3, 4)) returns 10",
"Delayed differential, lag specifies how many items delay, by default it is 1. e.g., x <- c(1, 5, 23, 29), diff(x) returns c(4, 18, 6)",
"Minimum. e.g., min(c(1, 2, 3, 4)) returns 1",
"Maximum. e.g., max(c(1, 2, 3, 4)) returns 4",
"Centralize the x by columns(center = TRUE), standardize the x(center = TRUE, scale = TRUE)")
)
kable(data, caption = "Statistical functions", escape = FALSE) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "bordered"),
full_width = FALSE) %>%
column_spec(1 : 2, width = "10cm", latex_column_spec = "c")
x <- c(1, 2, 3, 4, 5, 6, 7, 8)
mean(x)
sd(x)
n <- length(x)
meanx <- sum(x) / n
css <- sum((x - mean(x)) ^ 2)
sdx <- sqrt(css / (n - 1))
meanx
sdx
library(knitr)
library(kableExtra)
library(magrittr)
data <- data.frame(
distribution_name1 = c("Beta distribution", "Binominal distribution", "Cauchy distribution", "Non-centered chisquare distribution", "Exponential distribution", "F distribution", "Gamma distribution", "Geometry distribution", "Hypergeometric distribution", "Lognormal distribution"),
abbreviation1 = c("beta", "binom", "cauchy", "chisq", "exp", "f", "gamma", "geom", "hyper", "lnorm"),
distribution_name2 = c("Logistic distribution", "Multinominal distribution", "Negative binominal distribution", "Normal distribution", "Poisson distribution", "Wilcoxon sign rank distribution", "T distribution", "Uniform distribution", "Weibull distribution", "Wilcoxon rank sum distribution"),
abbreviation2 = c("logis", "multinom", "nbinom", "norm", "pois", "signrank", "t", "unif", "weibull", "wilcox")
)
kable(data, caption = "Probability functions") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "bordered"),
full_width = FALSE) %>%
column_spec(1 : 4, width = "5cm", latex_column_spec = "c")
# We want to draw the standard normal distribution density line on range [-3, 3]
# Function pretty just like the function linspace in MATLAB but slightly different
x <- pretty(c(-3, 3), 30)
# Calculate the density at the points in vector x
y <- dnorm(x)
# Make the graph
plot(x, y, type = "l", xlab = "Normal deviate", ylab = "Density", yaxs = "i")
# Calculate the cumulative distribution probability value on the parameter
pnorm(1.96)
# Calculate the quantile value at the probability point
qnorm(.9, mean = 500, sd = 100)
# Generate 50 normal random value whose mean is 50, standard deviation is 10
rnorm(50, mean = 50, sd = 10)
runif(5)
runif(5)
set.seed(1234)
runif(5)
set.seed(1234)
runif(5)
library(knitr)
library(kableExtra)
library(magrittr)
data <- data.frame(
mean_vector = c(230.7, 146.7, 3.6),
covariance_matrix = data.frame(v1 = c(15360.8, 6721.2, -47.1), v2 = c(6721.2, 4700.9, -16.5), v3 = c(-47.1, -16.5, 0.3))
)
kable(data, caption = "500 observations in three variate normal distribution") %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "bordered"),
full_width = FALSE) %>%
column_spec(1 : 2, width = "5cm", latex_column_spec = "c")
library(MASS)
options(digits = 3)
set.seed(1234)
mean <- c(230.7, 146.7, 3.6)
sigma <- matrix(c(15360.8, 6721.2, -47.1, 6721.2, 4700.9, -16.5, -47.1, -16.5, 0.3), nrow = 3, ncol = 3, byrow = FALSE)
mydata <- mvrnorm(500, mean, sigma)
mydata <- as.data.frame(mydata)
names(mydata) <- c("y", "x1", "x2")
dim(mydata)
head(mydata, n = 10)
library(MASS)
options(digits = 3)
set.seed(1234)
mean <- c(230.7, 146.7, 3.6)
sigma <- matrix(c(15360.8, 6721.2, -47.1, 6721.2, 4700.9, -16.5, -47.1, -16.5, 0.3), nrow = 3, ncol = 3, byrow = FALSE)
mydata <- mvrnorm(500, mean, sigma)
mydata <- as.data.frame(mydata)
names(mydata) <- c("y", "x1", "x2")
dim(mydata)
head(mydata, n = 10)
library(knitr)
library(kableExtra)
library(magrittr)
descriptions <- c(
"Counts the number of characters in x. <code>x <- c(\"ab\", \"cde\", \"fghij\")</code> returns <code>c(2, 3, 5)</code>",
"Extract or replace a substring in a character vector, <code>x <- \"abcdef\", substr(x, 2, 4)</code> returns \"bcd\", <code>substr(x, 2, 4) <- \"22222\"</code>, then x is \"a222ef\"",
"Search for pattern in x. If <code>fixed = FALSE</code>, pattern is a regular expression, if <code>fixed = TRUE</code>, pattern is a string. If <code>ignore.case = FALSE</code>, then case sensitive, the results are the suffix about pattern. <code>grep(\"A\", c(\"b\", \"A\", \"c\"), fixed = TRUE)</code> returns 2",
"Finds pattern in x and substitute it as replacement. If <code>fixed = FALSE</code>, pattern is a regular expression, if <code>fixed = TRUE</code>, pattern is a string. If <code>ignore.case = FALSE</code>, then case sensitive. <code>sub(\"\\\\\\\\s\", \".\", \"Hello There\")</code> returns Hello.There. \"\\\\s\" is a regular expression used to search space, use \"\\\\\\\\s\" because \"\\\\\" is the escape character in R",
"Split elements of character vector x at split. If <code>fixed = FALSE</code>, pattern is a regular expression, if <code>fixed = TRUE</code>, pattern is a string. <code>y <- strsplit(\"abc\", \"\")</code> returns a list contains one component, three elements, the content is  \"a\", \"b\", \"c\"",
"Concatenate strings, separator is sep. <code>paste(\"x\", 1 : 3, sep = \"\")</code> returns <code>c(\"x1\", \"x2\", \"x3\")</code>, <code>paste(\"x\", 1 : 3, sep = \"M\")</code> returns <code>c(\"xM1\", \"xM2\", \"xM3\")</code>, <code>paste(\"Today is \", date())</code> returns time",
"Uppercase. <code>toupper(\"abc\")</code> returns \"ABC\"",
"Lowercase. <code>tolower(\"ABC\")</code> returns \"abc\""
)
data <- data.frame(
functions = c("nchar(x)", "substr(x, start, stop)", "grep(pattern, x, ignore.case = FALSE, fixed = FALSE)", "sub(pattern, replacement, x, ignore.case = FALSE, fixed = FALSE)", "strsplit(x, split, fixed = FALSE)", "paste(..., sep = \" \")", "toupper(x)", "tolower(X)"),
description = descriptions,
stringsAsFactors = FALSE
)
kable(data, caption = "500 observations in three variate normal distribution", format = "html", escape = FALSE) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "bordered"), full_width = FALSE) %>%
column_spec(1, width = "5cm", latex_column_spec = "c") %>%
column_spec(2, width = "15cm", latex_column_spec = "c")
library(knitr)
library(kableExtra)
library(magrittr)
descriptions <- c("The length of object x, <code>x <- c(2, 5, 6, 9); length(x)</code> returns 4",
"Generate a series, <code>indices <- seq(1, 10, 2)</code>, then the values of indices are <code>c(1, 3, 5, 7, 9)</code>",
"Repeat x n times, <code>y <- rep(1 : 3, 2)</code>, then y is <code>c(1, 2, 3, 1, 2, 3)</code>",
"Divides the continuous variable x into a factor with n levels. To create an ordered factor, include the option <code>ordered_result = TRUE</code>",
"Create pretty breakpoints. Divides a continuous variable x into n intervals by selecting n + 1 equally spaced rounded values. Often used in plotting.",
"Concatenate the object in ..., outputs them on screen or in a file if specified. <code>firstname <- c(\"Jane\"); cat(\"Hello\", firstname, \"\\\\n\")")
data <- data.frame(
functions = c("length(x)", "seq(from, to, by)", "rep(x, n)", "cut(x, n)", "pretty(x, n)", "cat(..., file = \"myfile\", append = FALSE)"),
description = descriptions
)
kable(data, caption = "Other useful functions", format = "html", escape = FALSE) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed", "bordered"), full_width = FALSE) %>%
column_spec(1, width = "5cm", latex_column_spec = "c") %>%
column_spec(2, width = "15cm", latex_column_spec = "c")
?pretty
?round
round(3.5)
round(-3.5)
round(-3.6)
round(-3.4)
round(-3.49)
round(-3.51)
?runif
runif(10)
runif(10, min = -1, max = 5)
a <- 5
sqrt(a)
b <- c(1.243, 5.654, 2.99)
# round(x, digits = n), by default n is 0, and it can also be negative
round(b)
# runif(n, min = a, max = b), generate n numbers that follow the uniform
# distribution range a to b, by default, a = 0, b = 1
c <- matrix(runif(12), nrow = 3)
c
log(c)
mean(c)
?mean()
?sclae
?scale
# Set digits
options(digits = 2)
# Input data
name <- c("John Davis", "Angela Williams", "Bullwinkle Moose", "David Jones",
"Janice Markhammer", "Cheryl Cushing", "Reuven Ytzrhak",
"Greg Knox", "Joel England", "Mary Rayburn")
math <- c(502, 600, 412, 358, 495, 512, 410, 625, 573, 522)
science <- c(95, 99, 80, 82, 75, 85, 80, 95, 89, 86)
English <- c(25, 22, 18, 15, 20, 28, 15, 30, 27, 18)
roster <- data.frame(name, math, science, English, stringsAsFactors = FALSE)
# Calculate total scores
z <- scale(roster[, 2 : 4])
z
mean(math)
max(math)-min(math)
roster
score <- apply(z, 1, mean)
roster <- cbind(roster, score)
# Calculate the quantile
y <- quantile(score, c(.8, .6, .4, .2))
y
y[1]
y[1][2]
1-y[1]
2-y[1]
options(digits = 3)
2-y[1]
# Set digits
options(digits = 2)
# Input data
student <- c("John Davis", "Angela Williams", "Bullwinkle Moose", "David Jones",
"Janice Markhammer", "Cheryl Cushing", "Reuven Ytzrhak",
"Greg Knox", "Joel England", "Mary Rayburn")
math <- c(502, 600, 412, 358, 495, 512, 410, 625, 573, 522)
science <- c(95, 99, 80, 82, 75, 85, 80, 95, 89, 86)
English <- c(25, 22, 18, 15, 20, 28, 15, 30, 27, 18)
roster <- data.frame(student, math, science, English, stringsAsFactors = FALSE)
# Calculate total scores
# scale(x) can normalize the values in unit standard deviation
z <- scale(roster[, 2 : 4])
# Calculate the average score of each student
score <- apply(z, 1, mean)
roster <- cbind(roster, score)
# Calculate the quantile
y <- quantile(score, c(.8, .6, .4, .2))
# Grade the students
roster$grade[score >= y[1]] <- "A"
roster$grade[score < y[1] & score >= y[2]] <- "B"
roster$grade[score < y[2] & score >= y[3]] <- "C"
roster$grade[score < y[3] & score >= y[4]] <- "D"
roster$grade[score < y[4]] <- "F"
# Split students' names
name <- strsplit(roster$student)
# Set digits
options(digits = 2)
# Input data
student <- c("John Davis", "Angela Williams", "Bullwinkle Moose", "David Jones",
"Janice Markhammer", "Cheryl Cushing", "Reuven Ytzrhak",
"Greg Knox", "Joel England", "Mary Rayburn")
math <- c(502, 600, 412, 358, 495, 512, 410, 625, 573, 522)
science <- c(95, 99, 80, 82, 75, 85, 80, 95, 89, 86)
English <- c(25, 22, 18, 15, 20, 28, 15, 30, 27, 18)
roster <- data.frame(student, math, science, English, stringsAsFactors = FALSE)
# Calculate total scores
# scale(x) can normalize the values in unit standard deviation
z <- scale(roster[, 2 : 4])
# Calculate the average score of each student
score <- apply(z, 1, mean)
roster <- cbind(roster, score)
# Calculate the quantile
y <- quantile(score, c(.8, .6, .4, .2))
# Grade the students
roster$grade[score >= y[1]] <- "A"
roster$grade[score < y[1] & score >= y[2]] <- "B"
roster$grade[score < y[2] & score >= y[3]] <- "C"
roster$grade[score < y[3] & score >= y[4]] <- "D"
roster$grade[score < y[4]] <- "F"
# Split students' names
name <- strsplit(roster$student, " ")
name[[1]][1]
?sapply
[(name)
"["(name)
"["(name, 1)
?"["
?sapply
"["(name)
"["(name, 1)
"["(name, 1)
"["(name)
"["(name)[1]
"["(name)[[1]]
[(name)
[(name, 1)
Lastname <- sapply(name, "[", 2)
Firstname <- sapply(name, "[", 1)
roster < cbind(Firstname, Lastname, roster[, -1])
Lastname <- sapply(name, "[", 2)
Firstname <- sapply(name, "[", 1)
roster <- cbind(Firstname, Lastname, roster[, -1])
roter
roster
# Set digits
options(digits = 2)
# Input data
student <- c("John Davis", "Angela Williams", "Bullwinkle Moose", "David Jones",
"Janice Markhammer", "Cheryl Cushing", "Reuven Ytzrhak",
"Greg Knox", "Joel England", "Mary Rayburn")
math <- c(502, 600, 412, 358, 495, 512, 410, 625, 573, 522)
science <- c(95, 99, 80, 82, 75, 85, 80, 95, 89, 86)
English <- c(25, 22, 18, 15, 20, 28, 15, 30, 27, 18)
roster <- data.frame(student, math, science, English, stringsAsFactors = FALSE)
# Calculate total scores
# scale(x) can normalize the values in unit standard deviation
z <- scale(roster[, 2 : 4])
# Calculate the average score of each student
score <- apply(z, 1, mean)
roster <- cbind(roster, score)
# Calculate the quantile
y <- quantile(score, c(.8, .6, .4, .2))
# Grade the students
roster$grade[score >= y[1]] <- "A"
roster$grade[score < y[1] & score >= y[2]] <- "B"
roster$grade[score < y[2] & score >= y[3]] <- "C"
roster$grade[score < y[3] & score >= y[4]] <- "D"
roster$grade[score < y[4]] <- "F"
# Split students' names, the output is a list
name <- strsplit(roster$student, " ")
roster <- cbind(Firstname, roster[, -2])
roster
?order
# Set digits
options(digits = 2)
# Input data
student <- c("John Davis", "Angela Williams", "Bullwinkle Moose", "David Jones",
"Janice Markhammer", "Cheryl Cushing", "Reuven Ytzrhak",
"Greg Knox", "Joel England", "Mary Rayburn")
math <- c(502, 600, 412, 358, 495, 512, 410, 625, 573, 522)
science <- c(95, 99, 80, 82, 75, 85, 80, 95, 89, 86)
English <- c(25, 22, 18, 15, 20, 28, 15, 30, 27, 18)
roster <- data.frame(student, math, science, English, stringsAsFactors = FALSE)
# Calculate total scores
# scale(x) can normalize the values in unit standard deviation
z <- scale(roster[, 2 : 4])
# Calculate the average score of each student
score <- apply(z, 1, mean)
roster <- cbind(roster, score)
# Calculate the quantile
y <- quantile(score, c(.8, .6, .4, .2))
# Grade the students
roster$grade[score >= y[1]] <- "A"
roster$grade[score < y[1] & score >= y[2]] <- "B"
roster$grade[score < y[2] & score >= y[3]] <- "C"
roster$grade[score < y[3] & score >= y[4]] <- "D"
roster$grade[score < y[4]] <- "F"
# Split students' names, the output is a list
name <- strsplit(roster$student, " ")
# Note that "[" is a function that can extract part of an object, double quotes
# are a part of the function name
# For example, <code>"["(name, 1)</code> returns "John" "Davis"
# Function sapply(x, FUN), x is object, FUN is the specified function we want to
# apply
Lastname <- sapply(name, "[", 2)
Firstname <- sapply(name, "[", 1)
# We no longer need to keep student column in roster, so drop it by using index
# "-1" in the roster column, if the index be "-2", then drop the first two columns
roster <- cbind(Firstname, Lastname, roster[, -1])
# Order the students
roster <- roster[order(Lastname, Firstname), ]
roster
grade
?factor
grade <- "A"
temp <- grade
if (is.character(grade)) grade <- as.factor(grade) grade
grade <- "A"
if (is.character(grade)) grade <- as.factor(grade)
grade
mydate <- function(type = "long") {
switch(type,
long = format(Sys.time(), "%A %B %d %Y"),
short = format(Sys.time(), "%m-%d-%y"),
cat(type, "is not a recognized type\n")
)
}
mydate("long")
mydate("short")
mydate()
mydate("medium")
mtcars
mtcars[1:5,1:4]
cars<-mtcars[1:5,1:4]
dt(cars)
dt(dnorm(10))
install.packages("reshape2")
install.packages("vcd")
?table
table(Arthritis$Improved)
library(vcd)
table(Arthritis$Improved)
rgb(1,1,1)
rgb(1,1,1)
dose <- c(20, 30, 40, 45, 60)
drugA <- c(16, 20, 27, 40, 60)
drugB <- c(15, 18, 25, 31, 40)
opar <- par(no..readonly = TRUE)
par(lwd = 2, cex = 1.5, font.lab = 2)
# Set the range of y axis is 0 to 60, set title, x label, y label
plot(dose, drugA, type = "b", pch = 15, lty = 1, col = "red", ylim = c(0, 60),
main = "Drug A vs. Drug B", xlab = "Drug Dosage", ylab = "Drug Response")
lines(dose, drugB, type = "b", pch = 17, lty = 2, col = "blue")
?lines
abline(h = c(30), lwd = 1.5, lty = 2, col = "gray")
library(Hmisc)
# Set minor tick marks, there are 3 ranges between each major tick mark both x
# axis and y axis, its length is the half of the major tick marks
minor.tick(nx = 3, ny = 3, tick.ratio = 0.5)
legend("topleft", inset = .05, title = "Drug Type", c("A", "B"),
lty = c(1, 2), pch = c(15, 17), col = c("red", "blue"))
?aggregate
?lines
?barplot2
?paste
install.packages("plotrix")
state.region
?pie3D
library(plotrix)
?pie3D
jitter(dose)
?jitter
?seq
?pretty
?density
density(dose)
plot(density(c(-20, rep(0, 98), 20)), xlim = c(-4, 4))
?polygon
polygon(c(1:10),c(1:10),col="red",border="blue")
polygon(c(1:10),c(1:10),col="red",border="blue")
?polygon
polygon(1:10,1:10,col="red",border="blue")
polygon(c(1:10,9:1),c(1:10,10:1),col="red",border="blue")
polygon(c(1:10,9:1),c(1:10,11:20),col="red",border="blue")
polygon(c(1:10,9:1),c(1:10,12:20),col="red",border="blue")
plot(polygon(c(1:10,9:1),c(1:10,12:20),col="red",border="blue"))
polygon(c(1:10,9:1),c(1:10,12:20),col="red",border="blue")
install.packages("sm")
cyl.f <- factor(cyl, levels = c(4, 6, 8), labels = c("4 cylinder", "6 cylinder", "8 cylinder"))
library(sm)
attach(mtcars)
cyl.f <- factor(cyl, levels = c(4, 6, 8), labels = c("4 cylinder", "6 cylinder", "8 cylinder"))
cyl.f
cyl
mtcars
?sm.density.compare
sex <- c("Male", "Female")
sex <- factor(sex, levels = c(1, 2), labels = c("Male", "Female"))
sex
levels(cyl.f)
?levels
?boxplot
?boxplot.stats
x <- c(1:100, 1000)
boxplot(x)
boxplot.stats(x)
?boxplot.stats
install.packages("vioplot")
?rownames
?colnames
rownames(mtcars)
row.names(mtcars)
x <- mtcars[order(mpg), ]
attach(mtcars)
x <- mtcars[order(mpg), ]
x$cyl <- factor(x$cyl)
# Define a character vector named color into x
x$color[x$cyl == 4] <- "red"
x$color[x$cyl == 6] <- "blue"
x$color[x$cyl == 8] <- "darkgreen"
dotchart(x$mpg, labels = row.names(x), cex = .7, color = x$color, pch = 19, main = "Gas Mileage for Car Models\ngrouped by cylinder", xlab = "Miles per Gallon")
install.packages("pastecs")
install.packages(psych)
install.packages("psych")
head(mtcars)
head(mtcars,10)
>apply
?apply
?sapply
install.packages("doBy")
library(pROC)
install.packages("pROC")
library(pROC)
library(ggplot2)
y_true <- c(rep(1, 1744), rep(0, 2255))  # TP + FN = 1711+33, TN + FP = 2183+72
set.seed(123)
y_scores <- c(rnorm(1711, 0.9, 0.05),  # TP
rnorm(33, 0.2, 0.1),    # FN
rnorm(2183, 0.1, 0.1),  # TN
rnorm(72, 0.8, 0.1))    # FP
y_scores <- pmin(pmax(y_scores, 0), 1)
roc_obj <- roc(y_true, y_scores)
png(filename = "roc_curve.png", width = 800, height = 600)
plot(roc_obj, col = "blue", lwd = 2, main = paste("ROC Curve (AUC =", round(auc(roc_obj), 4), ")"))
abline(a = 0, b = 1, lty = 2, col = "gray")
dev.off()
cd
path
> plot(roc_obj, col = "blue", lwd = 2, main = paste("ROC Curve (AUC =", round(auc(roc_obj), 4), ")"))
getwd
getwd()
setwd("E:\R")
setwd("E:\\R")
setwd("E:/R")
library(pROC)
# 模擬資料：生成高品質預測分數，讓 AUC 接近 0.987
set.seed(123)
n <- 1000
y_true <- c(rep(1, 500), rep(0, 500))
y_scores <- c(rbeta(500, 9, 1), rbeta(500, 1, 9))  # 讓正類靠近 1，負類靠近 0
# 計算 ROC 與 AUC
roc_obj <- roc(y_true, y_scores)
# 檢查 AUC
print(auc(roc_obj))  # 你應該會看到約 0.987
plot(roc_obj, col = "blue", main = paste0("ROC Curve (AUC = ", round(auc(roc_obj), 4), ")"))
abline(a = 0, b = 1, col = "gray", lty = 2)
